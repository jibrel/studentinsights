# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rbnacl/all/rbnacl.rbi
#
# rbnacl-6.0.1
module RbNaCl
end
module RbNaCl::Sodium
  def primitive; end
  def self.extended(klass); end
  def sodium_constant(constant, name: nil, fallback: nil); end
  def sodium_function(name, function, arguments); end
  def sodium_function_with_return_code(name, function, arguments); end
  def sodium_primitive(primitive = nil); end
  def sodium_type(type = nil); end
end
module RbNaCl::Sodium::Version
  def self.sodium_version_string(*arg0); end
  def self.supported_version?(version); end
  def sodium_version_string(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::Serializable
  def inspect; end
  def to_s; end
  def to_str; end
end
module RbNaCl::KeyComparator
  def <=>(other); end
  def ==(other); end
  def compare32(other); end
  include Comparable
end
class RbNaCl::Auth
  def auth(message); end
  def compute_authenticator(_authenticator, _message); end
  def initialize(key); end
  def key; end
  def key_bytes; end
  def primitive; end
  def self.auth(key, message); end
  def self.key_bytes; end
  def self.tag_bytes; end
  def self.verify(key, authenticator, message); end
  def tag_bytes; end
  def verify(authenticator, message); end
  def verify_message(_authenticator, _message); end
end
module RbNaCl::Util
  def bin2hex(bytes); end
  def check_hmac_key(string, _description); end
  def check_length(string, length, description); end
  def check_string(string, length, description); end
  def check_string_validation(string); end
  def crypto_verify_16(*arg0); end
  def crypto_verify_32(*arg0); end
  def crypto_verify_64(*arg0); end
  def hex2bin(hex); end
  def prepend_zeros(n, message); end
  def remove_zeros(n, message); end
  def self.bin2hex(bytes); end
  def self.c_verify16(*args); end
  def self.c_verify32(*args); end
  def self.c_verify64(*args); end
  def self.check_hmac_key(string, _description); end
  def self.check_length(string, length, description); end
  def self.check_string(string, length, description); end
  def self.check_string_validation(string); end
  def self.crypto_verify_16(*arg0); end
  def self.crypto_verify_32(*arg0); end
  def self.crypto_verify_64(*arg0); end
  def self.hex2bin(hex); end
  def self.prepend_zeros(n, message); end
  def self.remove_zeros(n, message); end
  def self.verify16!(one, two); end
  def self.verify16(one, two); end
  def self.verify32!(one, two); end
  def self.verify32(one, two); end
  def self.verify64!(one, two); end
  def self.verify64(one, two); end
  def self.zero_pad(n, message); end
  def self.zeros(n = nil); end
  def verify16!(one, two); end
  def verify16(one, two); end
  def verify32!(one, two); end
  def verify32(one, two); end
  def verify64!(one, two); end
  def verify64(one, two); end
  def zero_pad(n, message); end
  def zeros(n = nil); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::Random
  def randombytes_buf(*arg0); end
  def self.c_random_bytes(*args); end
  def self.random_bytes(n = nil); end
  def self.randombytes_buf(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::SimpleBox
  def box(message); end
  def decrypt(enciphered_message); end
  def encrypt(message); end
  def extract_nonce(bytes); end
  def generate_nonce; end
  def initialize(box); end
  def nonce_bytes(*args, &block); end
  def open(enciphered_message); end
  def primitive(*args, &block); end
  def self.from_keypair(public_key, private_key); end
  def self.from_secret_key(secret_key); end
  extend Forwardable
end
module RbNaCl::Init
  def self.sodium_init(*arg0); end
  def sodium_init(*arg0); end
  extend FFI::Library
end
module RbNaCl::AEAD
end
class RbNaCl::AEAD::Base
  def data_len(data); end
  def decrypt(nonce, ciphertext, additional_data); end
  def do_decrypt(_message, _message_len, _nonce, _ciphertext, _additional_data); end
  def do_encrypt(_ciphertext, _ciphertext_len, _nonce, _message, _additional_data); end
  def encrypt(nonce, message, additional_data); end
  def initialize(key); end
  def key; end
  def key_bytes; end
  def nonce_bytes; end
  def primitive; end
  def self.key_bytes; end
  def self.nonce_bytes; end
  def self.tag_bytes; end
  def tag_bytes; end
end
module RbNaCl::Boxes
end
class RbNaCl::Boxes::Curve25519XSalsa20Poly1305
  def beforenm; end
  def box(nonce, message); end
  def crypto_box_curve25519xsalsa20poly1305_afternm(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_beforenm(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_beforenmbytes(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_boxzerobytes(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_noncebytes(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_open_afternm(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_publickeybytes(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_secretkeybytes(*arg0); end
  def crypto_box_curve25519xsalsa20poly1305_zerobytes(*arg0); end
  def decrypt(nonce, ciphertext); end
  def encrypt(nonce, message); end
  def initialize(public_key, private_key); end
  def nonce_bytes; end
  def open(nonce, ciphertext); end
  def primitive; end
  def self.box_curve25519xsalsa20poly1305_afternm(*args); end
  def self.box_curve25519xsalsa20poly1305_beforenm(*args); end
  def self.box_curve25519xsalsa20poly1305_open_afternm(*args); end
  def self.crypto_box_curve25519xsalsa20poly1305_afternm(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_beforenm(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_beforenmbytes(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_boxzerobytes(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_noncebytes(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_open_afternm(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_publickeybytes(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_secretkeybytes(*arg0); end
  def self.crypto_box_curve25519xsalsa20poly1305_zerobytes(*arg0); end
  def self.nonce_bytes; end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::Boxes::Curve25519XSalsa20Poly1305::PrivateKey
  def crypto_box_curve25519xsalsa20poly1305_keypair(*arg0); end
  def initialize(private_key); end
  def primitive; end
  def public_key; end
  def self.box_curve25519xsalsa20poly1305_keypair(*args); end
  def self.crypto_box_curve25519xsalsa20poly1305_keypair(*arg0); end
  def self.generate; end
  def to_bytes; end
  extend FFI::Library
  extend RbNaCl::Sodium
  include RbNaCl::KeyComparator
  include RbNaCl::Serializable
end
class RbNaCl::Boxes::Curve25519XSalsa20Poly1305::PublicKey
  def initialize(public_key); end
  def primitive; end
  def self.primitive; end
  def to_bytes; end
  include RbNaCl::KeyComparator
  include RbNaCl::Serializable
end
class RbNaCl::Boxes::Sealed
  def box(message); end
  def crypto_box_seal(*arg0); end
  def crypto_box_seal_open(*arg0); end
  def crypto_box_sealbytes(*arg0); end
  def decrypt(ciphertext); end
  def encrypt(message); end
  def initialize(public_key, private_key = nil); end
  def open(ciphertext); end
  def primitive; end
  def self.box_seal(*args); end
  def self.box_seal_open(*args); end
  def self.crypto_box_seal(*arg0); end
  def self.crypto_box_seal_open(*arg0); end
  def self.crypto_box_sealbytes(*arg0); end
  def self.from_private_key(private_key); end
  def self.from_public_key(public_key); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::SecretBoxes
end
class RbNaCl::SecretBoxes::XSalsa20Poly1305
  def box(nonce, message); end
  def crypto_secretbox_xsalsa20poly1305(*arg0); end
  def crypto_secretbox_xsalsa20poly1305_boxzerobytes(*arg0); end
  def crypto_secretbox_xsalsa20poly1305_keybytes(*arg0); end
  def crypto_secretbox_xsalsa20poly1305_noncebytes(*arg0); end
  def crypto_secretbox_xsalsa20poly1305_open(*arg0); end
  def crypto_secretbox_xsalsa20poly1305_zerobytes(*arg0); end
  def decrypt(nonce, ciphertext); end
  def encrypt(nonce, message); end
  def initialize(key); end
  def key_bytes; end
  def nonce_bytes; end
  def open(nonce, ciphertext); end
  def primitive; end
  def self.crypto_secretbox_xsalsa20poly1305(*arg0); end
  def self.crypto_secretbox_xsalsa20poly1305_boxzerobytes(*arg0); end
  def self.crypto_secretbox_xsalsa20poly1305_keybytes(*arg0); end
  def self.crypto_secretbox_xsalsa20poly1305_noncebytes(*arg0); end
  def self.crypto_secretbox_xsalsa20poly1305_open(*arg0); end
  def self.crypto_secretbox_xsalsa20poly1305_zerobytes(*arg0); end
  def self.key_bytes; end
  def self.nonce_bytes; end
  def self.secretbox_xsalsa20poly1305(*args); end
  def self.secretbox_xsalsa20poly1305_open(*args); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::Signatures
end
module RbNaCl::Signatures::Ed25519
  def crypto_sign_ed25519_bytes(*arg0); end
  def crypto_sign_ed25519_publickeybytes(*arg0); end
  def crypto_sign_ed25519_secretkeybytes(*arg0); end
  def crypto_sign_ed25519_seedbytes(*arg0); end
  def self.crypto_sign_ed25519_bytes(*arg0); end
  def self.crypto_sign_ed25519_publickeybytes(*arg0); end
  def self.crypto_sign_ed25519_secretkeybytes(*arg0); end
  def self.crypto_sign_ed25519_seedbytes(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::Signatures::Ed25519::SigningKey
  def crypto_sign_ed25519(*arg0); end
  def crypto_sign_ed25519_seed_keypair(*arg0); end
  def initialize(seed); end
  def keypair_bytes; end
  def primitive; end
  def self.crypto_sign_ed25519(*arg0); end
  def self.crypto_sign_ed25519_seed_keypair(*arg0); end
  def self.generate; end
  def self.sign_ed25519(*args); end
  def self.sign_ed25519_seed_keypair(*args); end
  def self.signature_bytes; end
  def sign(message); end
  def signature_bytes; end
  def to_bytes; end
  def verify_key; end
  extend FFI::Library
  extend RbNaCl::Sodium
  include RbNaCl::KeyComparator
  include RbNaCl::Serializable
end
class RbNaCl::Signatures::Ed25519::VerifyKey
  def crypto_sign_ed25519_open(*arg0); end
  def initialize(key); end
  def primitive; end
  def self.crypto_sign_ed25519_open(*arg0); end
  def self.sign_ed25519_open(*args); end
  def self.signature_bytes; end
  def signature_bytes; end
  def to_bytes; end
  def verify(signature, message); end
  extend FFI::Library
  extend RbNaCl::Sodium
  include RbNaCl::KeyComparator
  include RbNaCl::Serializable
end
module RbNaCl::GroupElements
end
class RbNaCl::GroupElements::Curve25519
  def crypto_scalarmult_curve25519(*arg0); end
  def initialize(point); end
  def mult(integer); end
  def self.base; end
  def self.base_point; end
  def self.crypto_scalarmult_curve25519(*arg0); end
  def self.scalarmult_curve25519(*args); end
  def to_bytes; end
  extend FFI::Library
  extend RbNaCl::Sodium
  include RbNaCl::KeyComparator
  include RbNaCl::Serializable
end
module RbNaCl::OneTimeAuths
end
class RbNaCl::OneTimeAuths::Poly1305 < RbNaCl::Auth
  def compute_authenticator(authenticator, message); end
  def crypto_onetimeauth_poly1305(*arg0); end
  def crypto_onetimeauth_poly1305_bytes(*arg0); end
  def crypto_onetimeauth_poly1305_keybytes(*arg0); end
  def crypto_onetimeauth_poly1305_verify(*arg0); end
  def self.crypto_onetimeauth_poly1305(*arg0); end
  def self.crypto_onetimeauth_poly1305_bytes(*arg0); end
  def self.crypto_onetimeauth_poly1305_keybytes(*arg0); end
  def self.crypto_onetimeauth_poly1305_verify(*arg0); end
  def self.onetimeauth_poly1305(*args); end
  def self.onetimeauth_poly1305_verify(*args); end
  def verify_message(authenticator, message); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::Hash
  def self.blake2b(data, options = nil); end
  def self.sha256(data); end
  def self.sha512(data); end
end
module RbNaCl::Hash::SHA256
  def crypto_hash_sha256(*arg0); end
  def crypto_hash_sha256_bytes(*arg0); end
  def self.crypto_hash_sha256(*arg0); end
  def self.crypto_hash_sha256_bytes(*arg0); end
  def self.hash_sha256(*args); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::Hash::SHA512
  def crypto_hash_sha512(*arg0); end
  def crypto_hash_sha512_bytes(*arg0); end
  def self.crypto_hash_sha512(*arg0); end
  def self.crypto_hash_sha512_bytes(*arg0); end
  def self.hash_sha512(*args); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::Hash::Blake2b
  def <<(message); end
  def crypto_generichash_blake2b_bytes_max(*arg0); end
  def crypto_generichash_blake2b_bytes_min(*arg0); end
  def crypto_generichash_blake2b_final(*arg0); end
  def crypto_generichash_blake2b_init_salt_personal(*arg0); end
  def crypto_generichash_blake2b_keybytes_max(*arg0); end
  def crypto_generichash_blake2b_keybytes_min(*arg0); end
  def crypto_generichash_blake2b_personalbytes(*arg0); end
  def crypto_generichash_blake2b_salt_personal(*arg0); end
  def crypto_generichash_blake2b_saltbytes(*arg0); end
  def crypto_generichash_blake2b_update(*arg0); end
  def digest; end
  def initialize(opts = nil); end
  def reset; end
  def self.crypto_generichash_blake2b_bytes_max(*arg0); end
  def self.crypto_generichash_blake2b_bytes_min(*arg0); end
  def self.crypto_generichash_blake2b_final(*arg0); end
  def self.crypto_generichash_blake2b_init_salt_personal(*arg0); end
  def self.crypto_generichash_blake2b_keybytes_max(*arg0); end
  def self.crypto_generichash_blake2b_keybytes_min(*arg0); end
  def self.crypto_generichash_blake2b_personalbytes(*arg0); end
  def self.crypto_generichash_blake2b_salt_personal(*arg0); end
  def self.crypto_generichash_blake2b_saltbytes(*arg0); end
  def self.crypto_generichash_blake2b_update(*arg0); end
  def self.digest(message, options); end
  def self.generichash_blake2b(*args); end
  def self.generichash_blake2b_final(*args); end
  def self.generichash_blake2b_init(*args); end
  def self.generichash_blake2b_update(*args); end
  def self.new(opts = nil); end
  def self.validate_opts(opts); end
  def update(message); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::Hash::Blake2b::State < FFI::Struct
end
module RbNaCl::PasswordHash
  def self.argon2(password, salt, opslimit, memlimit, digest_size = nil); end
  def self.argon2_str(password, opslimit = nil, memlimit = nil); end
  def self.argon2_supported?; end
  def self.argon2_valid?(password, str_digest); end
  def self.argon2i(password, salt, opslimit, memlimit, digest_size = nil); end
  def self.argon2id(password, salt, opslimit, memlimit, digest_size = nil); end
  def self.scrypt(password, salt, opslimit, memlimit, digest_size = nil); end
end
class RbNaCl::PasswordHash::SCrypt
  def crypto_pwhash_scryptsalsa208sha256(*arg0); end
  def crypto_pwhash_scryptsalsa208sha256_saltbytes(*arg0); end
  def digest(password, salt); end
  def initialize(opslimit, memlimit, digest_size = nil); end
  def self.crypto_pwhash_scryptsalsa208sha256(*arg0); end
  def self.crypto_pwhash_scryptsalsa208sha256_saltbytes(*arg0); end
  def self.scrypt(*args); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::PasswordHash::Argon2
  def crypto_pwhash(*arg0); end
  def crypto_pwhash_alg_argon2i13(*arg0); end
  def crypto_pwhash_alg_argon2id13(*arg0); end
  def crypto_pwhash_alg_default(*arg0); end
  def crypto_pwhash_memlimit_interactive(*arg0); end
  def crypto_pwhash_memlimit_max(*arg0); end
  def crypto_pwhash_memlimit_min(*arg0); end
  def crypto_pwhash_memlimit_moderate(*arg0); end
  def crypto_pwhash_memlimit_sensitive(*arg0); end
  def crypto_pwhash_opslimit_interactive(*arg0); end
  def crypto_pwhash_opslimit_max(*arg0); end
  def crypto_pwhash_opslimit_min(*arg0); end
  def crypto_pwhash_opslimit_moderate(*arg0); end
  def crypto_pwhash_opslimit_sensitive(*arg0); end
  def crypto_pwhash_saltbytes(*arg0); end
  def crypto_pwhash_str(*arg0); end
  def crypto_pwhash_str_verify(*arg0); end
  def crypto_pwhash_strbytes(*arg0); end
  def digest(password, salt, algo = nil); end
  def digest_str(password); end
  def initialize(opslimit, memlimit, digest_size = nil); end
  def self.crypto_pwhash(*arg0); end
  def self.crypto_pwhash_alg_argon2i13(*arg0); end
  def self.crypto_pwhash_alg_argon2id13(*arg0); end
  def self.crypto_pwhash_alg_default(*arg0); end
  def self.crypto_pwhash_memlimit_interactive(*arg0); end
  def self.crypto_pwhash_memlimit_max(*arg0); end
  def self.crypto_pwhash_memlimit_min(*arg0); end
  def self.crypto_pwhash_memlimit_moderate(*arg0); end
  def self.crypto_pwhash_memlimit_sensitive(*arg0); end
  def self.crypto_pwhash_opslimit_interactive(*arg0); end
  def self.crypto_pwhash_opslimit_max(*arg0); end
  def self.crypto_pwhash_opslimit_min(*arg0); end
  def self.crypto_pwhash_opslimit_moderate(*arg0); end
  def self.crypto_pwhash_opslimit_sensitive(*arg0); end
  def self.crypto_pwhash_saltbytes(*arg0); end
  def self.crypto_pwhash_str(*arg0); end
  def self.crypto_pwhash_str_verify(*arg0); end
  def self.crypto_pwhash_strbytes(*arg0); end
  def self.digest_size_value(digest_size); end
  def self.digest_str_verify(password, digest_string); end
  def self.memlimit_value(memlimit); end
  def self.opslimit_value(opslimit); end
  def self.pwhash(*args); end
  def self.pwhash_str(*args); end
  def self.pwhash_str_verify(*args); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
module RbNaCl::HMAC
end
class RbNaCl::HMAC::SHA256 < RbNaCl::Auth
  def compute_authenticator(authenticator, message); end
  def crypto_auth_hmacsha256_bytes(*arg0); end
  def crypto_auth_hmacsha256_final(*arg0); end
  def crypto_auth_hmacsha256_init(*arg0); end
  def crypto_auth_hmacsha256_keybytes(*arg0); end
  def crypto_auth_hmacsha256_update(*arg0); end
  def digest; end
  def hexdigest; end
  def initialize(key); end
  def self.auth_hmacsha256_final(*args); end
  def self.auth_hmacsha256_init(*args); end
  def self.auth_hmacsha256_update(*args); end
  def self.crypto_auth_hmacsha256_bytes(*arg0); end
  def self.crypto_auth_hmacsha256_final(*arg0); end
  def self.crypto_auth_hmacsha256_init(*arg0); end
  def self.crypto_auth_hmacsha256_keybytes(*arg0); end
  def self.crypto_auth_hmacsha256_update(*arg0); end
  def update(message); end
  def verify_message(authenticator, message); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::HMAC::SHA256State < FFI::Struct
end
class RbNaCl::HMAC::State < FFI::Struct
end
class RbNaCl::HMAC::SHA512256 < RbNaCl::Auth
  def compute_authenticator(authenticator, message); end
  def crypto_auth_hmacsha512256_bytes(*arg0); end
  def crypto_auth_hmacsha512256_final(*arg0); end
  def crypto_auth_hmacsha512256_init(*arg0); end
  def crypto_auth_hmacsha512256_keybytes(*arg0); end
  def crypto_auth_hmacsha512256_update(*arg0); end
  def digest; end
  def hexdigest; end
  def initialize(key); end
  def self.auth_hmacsha512256_final(*args); end
  def self.auth_hmacsha512256_init(*args); end
  def self.auth_hmacsha512256_update(*args); end
  def self.crypto_auth_hmacsha512256_bytes(*arg0); end
  def self.crypto_auth_hmacsha512256_final(*arg0); end
  def self.crypto_auth_hmacsha512256_init(*arg0); end
  def self.crypto_auth_hmacsha512256_keybytes(*arg0); end
  def self.crypto_auth_hmacsha512256_update(*arg0); end
  def update(message); end
  def verify_message(authenticator, message); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::HMAC::SHA512256State < FFI::Struct
end
class RbNaCl::HMAC::SHA512 < RbNaCl::Auth
  def compute_authenticator(authenticator, message); end
  def crypto_auth_hmacsha512_bytes(*arg0); end
  def crypto_auth_hmacsha512_final(*arg0); end
  def crypto_auth_hmacsha512_init(*arg0); end
  def crypto_auth_hmacsha512_keybytes(*arg0); end
  def crypto_auth_hmacsha512_update(*arg0); end
  def digest; end
  def hexdigest; end
  def initialize(key); end
  def self.auth_hmacsha512_final(*args); end
  def self.auth_hmacsha512_init(*args); end
  def self.auth_hmacsha512_update(*args); end
  def self.crypto_auth_hmacsha512_bytes(*arg0); end
  def self.crypto_auth_hmacsha512_final(*arg0); end
  def self.crypto_auth_hmacsha512_init(*arg0); end
  def self.crypto_auth_hmacsha512_keybytes(*arg0); end
  def self.crypto_auth_hmacsha512_update(*arg0); end
  def update(message); end
  def verify_message(authenticator, message); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::HMAC::SHA512State < FFI::Struct
end
class RbNaCl::AEAD::ChaCha20Poly1305Legacy < RbNaCl::AEAD::Base
  def crypto_aead_chacha20poly1305_abytes(*arg0); end
  def crypto_aead_chacha20poly1305_decrypt(*arg0); end
  def crypto_aead_chacha20poly1305_encrypt(*arg0); end
  def crypto_aead_chacha20poly1305_keybytes(*arg0); end
  def crypto_aead_chacha20poly1305_npubbytes(*arg0); end
  def do_decrypt(message, message_len, nonce, ciphertext, additional_data); end
  def do_encrypt(ciphertext, ciphertext_len, nonce, message, additional_data); end
  def self.aead_chacha20poly1305_decrypt(*args); end
  def self.aead_chacha20poly1305_encrypt(*args); end
  def self.crypto_aead_chacha20poly1305_abytes(*arg0); end
  def self.crypto_aead_chacha20poly1305_decrypt(*arg0); end
  def self.crypto_aead_chacha20poly1305_encrypt(*arg0); end
  def self.crypto_aead_chacha20poly1305_keybytes(*arg0); end
  def self.crypto_aead_chacha20poly1305_npubbytes(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::AEAD::ChaCha20Poly1305IETF < RbNaCl::AEAD::Base
  def crypto_aead_chacha20poly1305_ietf_abytes(*arg0); end
  def crypto_aead_chacha20poly1305_ietf_decrypt(*arg0); end
  def crypto_aead_chacha20poly1305_ietf_encrypt(*arg0); end
  def crypto_aead_chacha20poly1305_ietf_keybytes(*arg0); end
  def crypto_aead_chacha20poly1305_ietf_npubbytes(*arg0); end
  def do_decrypt(message, message_len, nonce, ciphertext, additional_data); end
  def do_encrypt(ciphertext, ciphertext_len, nonce, message, additional_data); end
  def self.aead_chacha20poly1305_ietf_decrypt(*args); end
  def self.aead_chacha20poly1305_ietf_encrypt(*args); end
  def self.crypto_aead_chacha20poly1305_ietf_abytes(*arg0); end
  def self.crypto_aead_chacha20poly1305_ietf_decrypt(*arg0); end
  def self.crypto_aead_chacha20poly1305_ietf_encrypt(*arg0); end
  def self.crypto_aead_chacha20poly1305_ietf_keybytes(*arg0); end
  def self.crypto_aead_chacha20poly1305_ietf_npubbytes(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::AEAD::XChaCha20Poly1305IETF < RbNaCl::AEAD::Base
  def crypto_aead_xchacha20poly1305_ietf_abytes(*arg0); end
  def crypto_aead_xchacha20poly1305_ietf_decrypt(*arg0); end
  def crypto_aead_xchacha20poly1305_ietf_encrypt(*arg0); end
  def crypto_aead_xchacha20poly1305_ietf_keybytes(*arg0); end
  def crypto_aead_xchacha20poly1305_ietf_npubbytes(*arg0); end
  def do_decrypt(message, message_len, nonce, ciphertext, additional_data); end
  def do_encrypt(ciphertext, ciphertext_len, nonce, message, additional_data); end
  def self.aead_xchacha20poly1305_ietf_decrypt(*args); end
  def self.aead_xchacha20poly1305_ietf_encrypt(*args); end
  def self.crypto_aead_xchacha20poly1305_ietf_abytes(*arg0); end
  def self.crypto_aead_xchacha20poly1305_ietf_decrypt(*arg0); end
  def self.crypto_aead_xchacha20poly1305_ietf_encrypt(*arg0); end
  def self.crypto_aead_xchacha20poly1305_ietf_keybytes(*arg0); end
  def self.crypto_aead_xchacha20poly1305_ietf_npubbytes(*arg0); end
  extend FFI::Library
  extend RbNaCl::Sodium
end
class RbNaCl::SelfTestFailure < RbNaCl::CryptoError
end
module RbNaCl::SelfTest
  def box_common_test(box); end
  def box_test; end
  def digital_signature_test; end
  def hmac_test(klass, tag); end
  def secret_box_test; end
  def self.box_common_test(box); end
  def self.box_test; end
  def self.digital_signature_test; end
  def self.hmac_test(klass, tag); end
  def self.secret_box_test; end
  def self.sha256_test; end
  def self.vector(name); end
  def sha256_test; end
  def vector(name); end
end
class RbNaCl::CryptoError < StandardError
end
class RbNaCl::LengthError < ArgumentError
end
class RbNaCl::IncorrectPrimitiveError < ArgumentError
end
class RbNaCl::BadSignatureError < RbNaCl::CryptoError
end
class RbNaCl::BadAuthenticatorError < RbNaCl::CryptoError
end
