# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack-attack/all/rack-attack.rbi
#
# rack-attack-5.4.2
class Rack::Attack
  def blocklisted?(*args, &block); end
  def call(env); end
  def initialize(app); end
  def safelisted?(*args, &block); end
  def self.blacklist(name, &block); end
  def self.blacklisted?(request); end
  def self.blacklisted_response; end
  def self.blacklisted_response=(res); end
  def self.blacklists; end
  def self.blocklist(name, &block); end
  def self.blocklist_ip(ip_address); end
  def self.blocklisted?(request); end
  def self.blocklisted_response; end
  def self.blocklisted_response=(arg0); end
  def self.blocklists; end
  def self.cache; end
  def self.clear!; end
  def self.clear_configuration; end
  def self.instrument(request); end
  def self.ip_blocklists; end
  def self.ip_safelists; end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.safelist(name, &block); end
  def self.safelist_ip(ip_address); end
  def self.safelisted?(request); end
  def self.safelists; end
  def self.throttle(name, options, &block); end
  def self.throttled?(request); end
  def self.throttled_response; end
  def self.throttled_response=(arg0); end
  def self.throttles; end
  def self.track(name, options = nil, &block); end
  def self.tracked?(request); end
  def self.tracks; end
  def self.whitelist(name, &block); end
  def self.whitelisted?(request); end
  def self.whitelists; end
  def throttled?(*args, &block); end
  def tracked?(*args, &block); end
  extend Forwardable
end
module Rack::Attack::FallbackPathNormalizer
  def self.normalize_path(path); end
end
module Rack
end
class Rack::Attack::Request < Rack::Request
end
class Rack::Attack::MisconfiguredStoreError < StandardError
end
class Rack::Attack::MissingStoreError < StandardError
end
class Rack::Attack::Cache
  def count(unprefixed_key, period); end
  def delete(unprefixed_key); end
  def do_count(key, expires_in); end
  def enforce_store_method_presence!(method_name); end
  def enforce_store_presence!; end
  def initialize; end
  def key_and_expiry(unprefixed_key, period); end
  def last_epoch_time; end
  def prefix; end
  def prefix=(arg0); end
  def read(unprefixed_key); end
  def reset_count(unprefixed_key, period); end
  def store; end
  def store=(store); end
  def write(unprefixed_key, value, expires_in); end
end
module Rack::Attack::StoreProxy
  def self.build(store); end
  def self.unwrap_active_support_stores(store); end
end
class Rack::Attack::StoreProxy::DalliProxy < SimpleDelegator
  def delete(key); end
  def increment(key, amount, options = nil); end
  def initialize(client); end
  def read(key); end
  def self.handle?(store); end
  def stub_with_if_missing; end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::MemCacheStoreProxy < SimpleDelegator
  def self.handle?(store); end
  def write(name, value, options = nil); end
end
class Rack::Attack::StoreProxy::MemCacheProxy < SimpleDelegator
  def delete(key, _options = nil); end
  def increment(key, amount, _options = nil); end
  def initialize(store); end
  def read(key); end
  def self.handle?(store); end
  def stub_with_if_missing; end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisProxy < SimpleDelegator
  def delete(key, _options = nil); end
  def increment(key, amount, options = nil); end
  def initialize(*args); end
  def read(key); end
  def self.handle?(store); end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisStoreProxy < Rack::Attack::StoreProxy::RedisProxy
  def read(key); end
  def self.handle?(store); end
  def write(key, value, options = nil); end
end
class Rack::Attack::StoreProxy::RedisCacheStoreProxy < SimpleDelegator
  def increment(name, amount = nil, options = nil); end
  def read(name, options = nil); end
  def self.handle?(store); end
  def write(name, value, options = nil); end
end
class Rack::Attack::Check
  def block; end
  def initialize(name, options = nil, block); end
  def matched_by?(request); end
  def name; end
  def type; end
end
class Rack::Attack::Blocklist < Rack::Attack::Check
  def initialize(name, block); end
end
class Rack::Attack::Throttle
  def block; end
  def cache; end
  def initialize(name, options, block); end
  def limit; end
  def matched_by?(request); end
  def name; end
  def period; end
  def type; end
end
