# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/pdf-reader/all/pdf-reader.rbi
#
# pdf-reader-2.2.0
module PDF
end
class PDF::Reader
  def doc_strings_to_utf8(obj); end
  def info; end
  def initialize(input, opts = nil); end
  def metadata; end
  def objects; end
  def page(num); end
  def page_count; end
  def pages; end
  def pdf_version; end
  def pdfdoc_to_utf8(obj); end
  def root; end
  def self.open(input, opts = nil, &block); end
  def utf16_to_utf8(obj); end
end
module PDF::Reader::ResourceMethods
  def color_spaces; end
  def fonts; end
  def graphic_states; end
  def patterns; end
  def procedure_sets; end
  def properties; end
  def shadings; end
  def xobjects; end
end
class PDF::Reader::Buffer
  def check_size_is_non_zero; end
  def empty?; end
  def find_first_xref_offset; end
  def in_content_stream?; end
  def initialize(io, opts = nil); end
  def merge_indirect_reference; end
  def peek_byte; end
  def pos; end
  def prepare_hex_token; end
  def prepare_inline_token; end
  def prepare_literal_token; end
  def prepare_regular_token; end
  def prepare_tokens; end
  def read(bytes, opts = nil); end
  def reset_pos; end
  def save_pos; end
  def state; end
  def string_token(token); end
  def token; end
end
class PDF::Reader::CidWidths
  def [](*args, &block); end
  def fetch(*args, &block); end
  def initialize(default, array); end
  def parse_array(default, array); end
  def parse_first_form(first, widths); end
  def parse_second_form(first, final, width); end
  extend Forwardable
end
class PDF::Reader::CMap
  def bfrange_type_one(start_code, end_code, dst); end
  def bfrange_type_two(start_code, end_code, dst); end
  def build_parser(instructions); end
  def decode(c); end
  def initialize(data); end
  def map; end
  def process_bfchar_instructions(instructions); end
  def process_bfrange_instructions(instructions); end
  def process_data(data); end
  def size; end
  def str_to_int(str); end
end
class PDF::Reader::Encoding
  def convert_to_utf8(str); end
  def default_mapping; end
  def differences; end
  def differences=(diff); end
  def get_mapping_file(enc); end
  def get_unpack(enc); end
  def glyphlist; end
  def initialize(enc); end
  def int_to_name(glyph_code); end
  def int_to_utf8_string(glyph_code); end
  def internal_int_to_utf8_string(glyph_code); end
  def little_boxes(times); end
  def load_mapping(file); end
  def to_utf8(str); end
  def unpack; end
  def utf8_conversion_impossible?; end
end
class PDF::Reader::Error
  def self.assert_equal(lvalue, rvalue); end
  def self.str_assert(lvalue, rvalue, chars = nil); end
  def self.str_assert_not(lvalue, rvalue, chars = nil); end
end
class PDF::Reader::MalformedPDFError < RuntimeError
end
class PDF::Reader::InvalidPageError < ArgumentError
end
class PDF::Reader::InvalidObjectError < PDF::Reader::MalformedPDFError
end
class PDF::Reader::UnsupportedFeatureError < RuntimeError
end
class PDF::Reader::EncryptedPDFError < PDF::Reader::UnsupportedFeatureError
end
module PDF::Reader::Filter
  def self.with(name, options = nil); end
end
class PDF::Reader::Filter::Ascii85
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::Filter::AsciiHex
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::Filter::Depredict
  def filter(data); end
  def initialize(options = nil); end
  def png_depredict(data); end
  def tiff_depredict(data); end
end
class PDF::Reader::Filter::Flate
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::Filter::Lzw
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::Filter::Null
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::Filter::RunLength
  def filter(data); end
  def initialize(options = nil); end
end
class PDF::Reader::SynchronizedCache
  def [](key); end
  def []=(key, value); end
  def initialize; end
end
module PDF::Reader::WidthCalculator
end
class PDF::Reader::WidthCalculator::BuiltIn
  def control_character?(code_point); end
  def glyph_width(code_point); end
  def initialize(font); end
end
class PDF::Reader::WidthCalculator::Composite
  def glyph_width(code_point); end
  def initialize(font); end
end
class PDF::Reader::WidthCalculator::TrueType
  def glyph_width(code_point); end
  def glyph_width_from_descriptor(code_point); end
  def glyph_width_from_font(code_point); end
  def initialize(font); end
end
class PDF::Reader::WidthCalculator::TypeZero
  def glyph_width(code_point); end
  def initialize(font); end
end
class PDF::Reader::WidthCalculator::TypeOneOrThree
  def glyph_width(code_point); end
  def initialize(font); end
end
class PDF::Reader::Font
  def basefont; end
  def build_width_calculator; end
  def cid_default_width; end
  def cid_widths; end
  def default_encoding(font_name); end
  def descendantfonts; end
  def descendantfonts=(arg0); end
  def encoding; end
  def encoding=(arg0); end
  def extract_base_info(obj); end
  def extract_descendants(obj); end
  def extract_descriptor(obj); end
  def first_char; end
  def font_descriptor; end
  def glyph_width(code_point); end
  def initialize(ohash, obj); end
  def last_char; end
  def subtype; end
  def subtype=(arg0); end
  def to_utf8(params); end
  def to_utf8_via_cmap(params); end
  def to_utf8_via_encoding(params); end
  def tounicode; end
  def tounicode=(arg0); end
  def unpack(data); end
  def widths; end
end
class PDF::Reader::FontDescriptor
  def ascent; end
  def avg_width; end
  def cap_height; end
  def descent; end
  def font_bounding_box; end
  def font_family; end
  def font_flags; end
  def font_name; end
  def font_stretch; end
  def font_weight; end
  def glyph_to_pdf_scale_factor; end
  def glyph_width(char_code); end
  def initialize(ohash, fd_hash); end
  def italic_angle; end
  def leading; end
  def max_width; end
  def missing_width; end
  def stem_v; end
  def ttf_program_stream; end
  def x_height; end
end
class PDF::Reader::FormXObject
  def cached_tokens_key; end
  def callback(receivers, name, params = nil); end
  def content_stream(receivers, instructions); end
  def content_stream_md5; end
  def font_objects; end
  def initialize(page, xobject, options = nil); end
  def raw_content; end
  def resources; end
  def tokens; end
  def walk(*receivers); end
  def xobject; end
  include PDF::Reader::ResourceMethods
end
class PDF::Reader::GlyphHash
  def initialize; end
  def load_adobe_glyph_mapping; end
  def name_to_unicode(name); end
  def unicode_to_name(codepoint); end
end
class PDF::Reader::LZW
  def self.create_new_string(string_table, some_code, other_code); end
  def self.decode(data); end
end
class PDF::Reader::LZW::BitStream
  def initialize(data, bits_in_chunk); end
  def read; end
  def set_bits_in_chunk(bits_in_chunk); end
end
class PDF::Reader::LZW::StringTable < Hash
  def [](key); end
  def add(string); end
  def initialize; end
  def string_table_pos; end
end
class PDF::Reader::ObjectCache
  def [](key); end
  def []=(key, value); end
  def cacheable?(obj); end
  def each(&block); end
  def each_key(&block); end
  def each_pair(&block); end
  def each_value(&block); end
  def empty?; end
  def fetch(key, local_default = nil); end
  def has_key?(key); end
  def has_value?(value); end
  def hits; end
  def include?(key); end
  def initialize(lru_size = nil); end
  def key?(key); end
  def keys; end
  def length; end
  def member?(key); end
  def misses; end
  def size; end
  def to_s; end
  def update_stats(key); end
  def values; end
end
class PDF::Reader::ObjectHash
  def [](key); end
  def build_security_handler(opts = nil); end
  def decrypt(ref, obj); end
  def default; end
  def default=(arg0); end
  def deref!(key); end
  def deref(key); end
  def deref_internal!(key, seen); end
  def each(&block); end
  def each_key(&block); end
  def each_pair(&block); end
  def each_value(&block); end
  def empty?; end
  def encrypted?; end
  def extract_io_from(input); end
  def fetch(key, local_default = nil); end
  def get_page_objects(ref); end
  def has_key?(check_key); end
  def has_value?(value); end
  def include?(check_key); end
  def initialize(input, opts = nil); end
  def key?(check_key); end
  def keys; end
  def length; end
  def member?(check_key); end
  def new_buffer(offset = nil); end
  def obj_type(ref); end
  def object(key); end
  def object_streams; end
  def page_references; end
  def pdf_version; end
  def read_as_binary(input); end
  def read_version; end
  def sec_handler; end
  def sec_handler?; end
  def size; end
  def stream?(ref); end
  def to_a; end
  def to_s; end
  def trailer; end
  def value?(check_key); end
  def values; end
  def values_at(*ids); end
  def xref; end
  include Enumerable
end
class PDF::Reader::ObjectStream
  def [](objid); end
  def buffer; end
  def first; end
  def initialize(stream); end
  def offsets; end
  def size; end
end
class PDF::Reader::PagesStrategy
end
class PDF::Reader::Parser
  def array; end
  def dictionary; end
  def hex_string; end
  def initialize(buffer, objects = nil); end
  def object(id, gen); end
  def parse_token(operators = nil); end
  def pdf_name; end
  def stream(dict); end
  def string; end
end
class PDF::Reader::PrintReceiver
  def callbacks; end
  def callbacks=(arg0); end
  def initialize; end
  def method_missing(methodname, *args); end
  def respond_to?(meth); end
end
class PDF::Reader::Reference
  def ==(obj); end
  def eql?(obj); end
  def gen; end
  def hash; end
  def id; end
  def initialize(id, gen); end
  def to_a; end
  def to_i; end
end
class PDF::Reader::RegisterReceiver
  def all(methodname); end
  def all_args(methodname); end
  def callbacks; end
  def callbacks=(arg0); end
  def count(methodname); end
  def final_occurance_of(methodname); end
  def first_occurance_of(methodname); end
  def initialize; end
  def method_missing(methodname, *args); end
  def respond_to?(meth); end
  def series(*methods); end
end
class PDF::Reader::NullSecurityHandler
  def decrypt(buf, _ref); end
  def self.supports?(encrypt); end
end
class PDF::Reader::StandardSecurityHandler
  def auth_owner_pass(pass); end
  def auth_user_pass(pass); end
  def build_standard_key(pass); end
  def decrypt(buf, ref); end
  def decrypt_aes128(buf, ref); end
  def decrypt_rc4(buf, ref); end
  def encrypt_key; end
  def file_id; end
  def initialize(opts = nil); end
  def key_length; end
  def make_file_key(user_pass); end
  def owner_key; end
  def pad_pass(p = nil); end
  def password; end
  def permissions; end
  def revision; end
  def self.supports?(encrypt); end
  def user_key; end
  def xor_each_byte(buf, int); end
end
class PDF::Reader::StandardSecurityHandlerV5
  def auth_owner_pass(password); end
  def auth_user_pass(password); end
  def build_standard_key(pass); end
  def decrypt(buf, ref); end
  def encrypt_key; end
  def initialize(opts = nil); end
  def key_length; end
  def self.supports?(encrypt); end
end
class PDF::Reader::UnimplementedSecurityHandler
  def decrypt(buf, ref); end
  def self.supports?(encrypt); end
end
class PDF::Reader::Stream
  def data; end
  def data=(arg0); end
  def hash; end
  def hash=(arg0); end
  def initialize(hash, data); end
  def unfiltered_data; end
end
class PDF::Reader::TextRun
  def +(other); end
  def <=>(other); end
  def character_count; end
  def endx; end
  def font_size; end
  def initialize(x, y, width, font_size, text); end
  def inspect; end
  def mean_character_width; end
  def mergable?(other); end
  def mergable_range; end
  def text; end
  def to_s; end
  def width; end
  def x; end
  def y; end
  include Comparable
end
class PDF::Reader::TransformationMatrix
  def a; end
  def b; end
  def c; end
  def d; end
  def e; end
  def f; end
  def faster_multiply!(a2, b2, c2, d2, e2, f2); end
  def horizontal_displacement_multiply!(e2); end
  def horizontal_displacement_multiply_reversed!(a2, b2, c2, d2, e2, f2); end
  def initialize(a, b, c, d, e, f); end
  def inspect; end
  def multiply!(a, b = nil, c = nil, d = nil, e = nil, f = nil); end
  def regular_multiply!(a2, b2, c2, d2, e2, f2); end
  def to_a; end
  def xy_scaling_multiply!(a2, b2, c2, d2, e2, f2); end
  def xy_scaling_multiply_reversed!(a2, b2, c2, d2, e2, f2); end
end
class PDF::Reader::PageState
  def begin_text_object; end
  def build_fonts(raw_fonts); end
  def clone_state; end
  def concatenate_matrix(a, b, c, d, e, f); end
  def ctm; end
  def ctm_transform(x, y); end
  def current_font; end
  def end_text_object; end
  def find_color_space(label); end
  def find_font(label); end
  def find_xobject(label); end
  def font_size; end
  def identity_matrix; end
  def initialize(page); end
  def invoke_xobject(label); end
  def move_text_position(x, y); end
  def move_text_position_and_set_leading(x, y); end
  def move_to_next_line_and_show_text(str); end
  def move_to_start_of_next_line; end
  def process_glyph_displacement(w0, tj, word_boundary); end
  def restore_graphics_state; end
  def save_graphics_state; end
  def set_character_spacing(char_spacing); end
  def set_horizontal_text_scaling(h_scaling); end
  def set_spacing_next_line_show_text(aw, ac, string); end
  def set_text_font_and_size(label, size); end
  def set_text_leading(leading); end
  def set_text_matrix_and_text_line_matrix(a, b, c, d, e, f); end
  def set_text_rendering_mode(mode); end
  def set_text_rise(rise); end
  def set_word_spacing(word_spacing); end
  def show_text_with_positioning(params); end
  def stack_depth; end
  def state; end
  def text_rendering_matrix; end
  def trm_transform(x, y); end
end
class PDF::Reader::PageLayout
  def col_count; end
  def col_multiplier; end
  def each_line(&block); end
  def group_chars_into_runs(chars); end
  def initialize(runs, mediabox); end
  def interesting_rows(rows); end
  def local_string_insert(haystack, needle, index); end
  def mean(collection); end
  def merge_runs(runs); end
  def row_count; end
  def row_multiplier; end
  def to_s; end
end
class PDF::Reader::PageTextReceiver
  def begin_text_object(*args, &block); end
  def concatenate_matrix(*args, &block); end
  def content; end
  def end_text_object(*args, &block); end
  def font_size(*args, &block); end
  def internal_show_text(string); end
  def invoke_xobject(label); end
  def move_text_position(*args, &block); end
  def move_text_position_and_set_leading(*args, &block); end
  def move_to_next_line_and_show_text(str); end
  def move_to_start_of_next_line(*args, &block); end
  def options; end
  def page=(page); end
  def restore_graphics_state(*args, &block); end
  def save_graphics_state(*args, &block); end
  def set_character_spacing(*args, &block); end
  def set_horizontal_text_scaling(*args, &block); end
  def set_spacing_next_line_show_text(aw, ac, string); end
  def set_text_font_and_size(*args, &block); end
  def set_text_leading(*args, &block); end
  def set_text_matrix_and_text_line_matrix(*args, &block); end
  def set_text_rendering_mode(*args, &block); end
  def set_text_rise(*args, &block); end
  def set_word_spacing(*args, &block); end
  def show_text(string); end
  def show_text_with_positioning(params); end
  def state; end
  extend Forwardable
end
class PDF::Reader::Token < String
  def initialize(val); end
end
class PDF::Reader::XRef
  def [](ref); end
  def calc_junk_offset(io); end
  def each(&block); end
  def initialize(io); end
  def load_offsets(offset = nil); end
  def load_xref_stream(stream); end
  def load_xref_table(buf); end
  def new_buffer(offset = nil); end
  def size; end
  def store(id, gen, offset); end
  def trailer; end
  def unpack_bytes(bytes); end
  include Enumerable
end
class PDF::Reader::OrientationDetector
  def detect_orientation; end
  def initialize(attributes); end
  def orientation; end
end
class PDF::Reader::Page
  def ancestors(origin = nil); end
  def attributes; end
  def cache; end
  def callback(receivers, name, params = nil); end
  def content_stream(receivers, instructions); end
  def initialize(objects, pagenum, options = nil); end
  def inspect; end
  def number; end
  def objects; end
  def orientation; end
  def page_object; end
  def page_with_ancestors; end
  def raw_content; end
  def resources; end
  def root; end
  def select_inheritable(obj); end
  def text; end
  def to_s; end
  def walk(*receivers); end
  include PDF::Reader::ResourceMethods
end
class PDF::Hash < PDF::Reader::ObjectHash
  def initialize(input); end
  def version; end
end
